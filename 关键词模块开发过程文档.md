关键词分类模块开发流程：

1.数据预处理：

分词：将文本分割成单词或短语。对于中文，可以使用jieba分词库，将文本分割为单词或短语

去除停用词：停用词是指在文本中频繁出现但对语义贡献不大的词（如“的”“是”等），本次开发过程使用了TF-IDF算法计算每个词在所有笔记中的逆文档频率（IDF），其公式为IDF(t) = log( N / df(t) )。N为作为分析数据的笔记数量，df(t)为包含词语t的文档数量。IDF值较低，说明该词语在所有文档中出现的文档数量较高，接近我们对于停用词（高频率出现，但对理解笔记主题无帮助）的定义。将IDF值低于预先设定阈值的词语加入停用词列表。避免了该类词语出现在关键词提取中，提高了关键词筛选的准确性。



为何使用TF-IDF算法：

TF（词频）：该词语在该篇笔记中出现的频率多少。

IDF（逆文档频率）：该词语在所有文档中多罕见。

TF-IDF：两者相乘，在显眼和罕见中作权衡：在本篇很显眼，但在整体很罕见。符合我们对于关键词的定义。

公式拆解如下：

TF(t,d) = 词 t 在文档 d 中出现的次数 / 文档 d 的总词数

IDF(t)  = ln( (1 + N) / (1 + df(t)) ) + 1
‑ N：总文档数
‑ df(t)：出现词 t 的文档数

TF-IDF(t,d) = TF(t,d) × IDF(t)

注：sklearn 为了防止除 0，给分子分母都 +1，最后再加 1 平滑。



笔记数量越多，IDF的统计意义越稳定，停用词表更可靠。

预计笔记数量：最少100篇。



2.关键词提取：

使用TF-IDF算法计算每个词的重要性，提取权重最高的词作为关键词，依照设定的关键词个数，呈现指定数量的关键词，依照权重从高到低的顺序排序。



3.语义分析：（目标：输入每篇笔记的top-N关键词列表，输出高维语义向量，供下游KMeans、HDBSCAN等聚类算法使用）

​	1.使用`transformers`库中预训练的语言模型SBERT对笔记文本转化为语义向量。

​	2.在semantic_analysis.py中将关键词列表变为“语义向量”，给关键词赋予可计算的语义

​	3.在main.py中加入快速聚类测试，使用无监督聚类算法KMeans将历史笔记自动分成若干类别。检验语义分析的效果，从而低成本的决定是否调整k、换模型、还是直接进入正式分类



 KMeans 算法步骤

1. 随机选 k 个中心点；
2. 把每个样本分配到最近的中心；
3. 重新计算中心；
4. 重复 2-3 直到收敛。
   • `fit_predict` 一次性完成训练 + 预测，返回每个样本的簇编号（0,1,…,k-1）。
   • `random_state=42` 保证每次运行结果一致，便于调试。



KMeans算法原理：

• 语义假设
如果两篇笔记的关键词在语义向量空间中的欧氏距离很小，那么它们的内容主题大概率相似。

• KMeans 的适用性
768 维空间虽然高，但只要主题数 k 远小于样本量，KMeans 仍能较快收敛；
同时它足够简单，方便快速试错。

• 评估与迭代
将同一簇里的关键词打印出来，人工看是否主题一致：
– 若出现“会议”和“考试”混在同一簇，说明 k 偏小或关键词权重需调整；
– 若一个簇只有 1~2 条笔记，说明 k 偏大。
通过几次 `k=3,4,5,6,7` 的对比，就能找到最合适的类别数，为 auto_classification.py 的“人工定义类目”或“种子向量”提供依据。



4.自动分类：

特征提取：将语义分析得到的向量作为特征输入分类模型。

传统机器学习模型：

使用TF-IDF提取的特征训练SVM或决策树模型。



5.标签化：

根据分类结果和关键词提取结果，为笔记生成标签。

项目文件结构参考如下：

```
project/
├─ main.py                 # 主入口：按顺序调用各模块
├─ keyword_extraction.py   # 关键词提取（含 TF-IDF）
├─ semantic_analysis.py    # 预留：语义聚类或词向量分析
├─ auto_classification.py  # 预留：把关键词映射到类目
├─ tagging.py              # 预留：生成并存储最终标签
├─ utils.py                # 公共工具：路径、日志、配置
└─ data/                   # 存放停用词、语料、模型等
   ├─ stop_words.txt
   └─ corpus/ ...
```

通过这种方式，每个模块都有独立的文件，便于管理和维护。同时，主程序main.py负责调用各个模块的功能，实现完整的流程。





